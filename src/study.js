//  리액트의 기본 3요소
//  1. Virtual DOM
//  2. JSX
//  3. Component


//  * 문서 객체 모델 - DOM(Document Object Model)
//  - 웹 문서(HTML, SVG, XML 등)을 브라우저가 이해할 수 있는 형태
//  - 쉽게 말해 하나의 웹 사이트의 정보를 모두 담고 있는 큰 그릇
//  - 리액트는 빠른 화면 내용을 변경하기 위한 가상의 DOM(Virtual DOM)을 사용
//  - 화면이 업데이트 된다 == DOM이 수정된다
//  - 리액트는 화면 업데이트 시 DOM을 직접 수정하지 않고
//     업데이트 해야 할 최소한의 부분만을 찾아서 업데이트

    //  StateChange(상태변경) > Compute Diff(차이 계산) > Re-render(다시 그리기)
    //  StateChange : 상태에 변경사항이 발생하면
    //  ComputeDiff : Virtual DOM에서 업데이트가 필요한 최소한의 부분을 비교하여 검색하고
    //  Re-render : 검색된 부분만을 업데이트하고 다시 렌더링하면서 변경된 내용을 빠르게 사용자에게 보여줌



//  * JSX (Java Script XML)
//  : XML 구문에 자바스크립트 코드를 결합하는 용도로 만들어진 구문.
//  React.createElement 호출 코드를 간결하게 하기 위해 고안된 것으로
//  자바스크립트 언어를 확장하는 방식으로 구현
//  즉, 반환값은 가상 DOM(Virtual DOM) 객체이다.
//  따라서 변수나 배열에 담을 수 있다.



//  * 컴포넌트 (Component)
//  - 리액트로 만들어진 앱을 이루는 최소한의 단위
//  - 컴포넌트는 데이터(props)를 입력받아 View(state) 상태에 따라 DOM Node를 출력하는 함수
//      >> "props"라고 하는 임의의 입력을 받은 후
//          화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반환
//  - 구성요소라는 뜻이며, 컴포넌트는 블록 형식이라 재사용성이 뛰어나다.
//  - UI를 재사용 가능한 개별적인 여러 조각으로 나누고, 각 조각을 개별적으로 나누어 코딩
//      == 하나의 컴포넌트는 여러 컴포넌트로 조합할 수 있다 (== 레고와 같다고 생각하면 쉬움)
//  - 컴포넌트 이름은 항상 대문자로 시작 (소문자로 시작하는 컴포넌트는 DOM 으로 취급)

//  컴포넌트의 종류
    //  1. 함수형 컴포넌트 (Functional Component)
    //  - 상태(State)와 라이프사이클 메서드가 필요 없는 경우에 유용
    //  - 함수처럼 정의되고 매개변수로 props 객체를 받고 JSX 로 반환 (== 렌더링)
    //  -
    //  2. 클래스형 컴포넌트 (Class Component)
    //  - ES6의 클래스를 활용하며, 컴포넌트의 상태(State)가 내장되어 있음
    //  - 리액트의 Component 클래스를 상속받으며 render() 메서드를 통해 UI를 렌더링



//  * Props 와 State
//  Props : 컴포넌트 외부에서 컴포넌트에게 주는 데이터
//              == 부모 컴포넌트 > 자식 컴포넌트 로 전달하는 데이터로 자식 컴포넌트에서 수정불가
//  State : 컴포넌트 내부에서 변경할 수 있는 동적인 데이터.
//            예전에는 클래스 컴포넌트에만 사용할 수 있었던 기능이나
//            현재는 Hooks을 사용하면 함수형 컴포넌트에도 사용 가능.
//            상태가 변경되면 해당 컴포넌트는 다시 렌더링 된다.



//  * 렌더링(Rendering)
//  : 리액트에서 렌더링은 컴포넌트가 UI를 화면에 표시하기 위해
//  JSX를 HTML로 변환하고 브라우저 DOM에 반영하는 과정을 의미
//  리액트는 상태(state)나 속성(props)의 변경에 따라 컴포넌트를 다시 렌더링하고,
//  이 과정에서 변경된 부분만 효율적으로 업데이트 함



//  * 훅(Hook)
//  : 함수형 컴포넌트에서 상태(state)와 컴포넌트 생명주기(lifecycle)를 사용할 수 있게 하는 기능
    //  훅의 특징
        //  1. 함수형 컴포넌트에서 상태와 생명주기 관리
        //  2. 코드 간결화
        //  3. 클래스 없이도 강력한 기능 제공
        //  4. 리액트 16.8 이상에서 도입(최신 리액트 개발에서는 표준처럼 사용됨)

        //  대표적인 훅
        //  1. useState (상태 관리)         ***
        //  - 상태(state)를 관리하기 위한 훅
        //  - 상태와 상태를 업데이트하는 함수를 제공

        //  2. useEffect (사이드 이펙트 관리)         ***
        //  - 컴포넌트가 렌더링되거나 상태가 변경될 때 실행되는 코드를 정의
        //  - 주로 데이터 fetching, DOM 조작, 구독(subscription) 등에 사용됨

        //  3. useContext (컨텍스트 사용)         ***
        //  - 리액트의 Context API를 사용해 전역 상태를 쉽게 관리할 수 있도록 도와줌

        //  4. useReducer (복잡한 상태 관리)
        //  - 복잡한 상태를 관리할 때 useState 보다 더 강력한 기능을 제공
        //  - Redux와 유사한 방식으로 동작

        //  5. useRef (참조 관리)
        //  - DOM 요소나 컴포넌트의 **참조(reference)**를 저장할 때 사용
        //  - 값이 변경되어도 컴포넌트가 다시 렌더링되지 않음

    //  훅의 사용 규칙
    //  1. 최상위 레벨에서만 호출 (조건문이나 반복문 내부에서 호출 X)
    //  2. 리액트 함수형 컴포넌트 또는 커스텀 훅에서만 호출 (일반 자바스크립트 함수에서 호출 X)



//  export default function (컴포넌트명) 은
//  자바 스크립트의 모듈 시스템과 함수 선언을 결합한 구문으로
//  특정 컴포넌트를 기본 내보내기(default export)로 정의하는 것을 의미
//  리액트에서 주로 컴포넌트를 모듈화 하여 다른 파일에서 쉽게 가져다 쓸 수 있게 하는 데 사용됨
//  * 리액트에서 컴포넌트 모듈화란?
//  : 각 컴포넌트를 별도의 파일로 작성하고, 이를 모듈로 내보내는 것
//  * 참고 : 자바스크립트의 모듈 시스템
//  : 하나의 파일에서 정의된 코드를 다른 파일에서 가져와 사용할 수 있는 방식
//      - export : 다른 파일에서 사용 가능하도록 코드를 내보내기
//      - import : 다른 파일에서 내보낸 코드를 가져오기



//  리액트에서 Const 는 ES6에서 도입된 변수 선언 방식 중 하나로
//  변경 불가능한(immutable) 값을 선언할 때 사용됨
//  * const 로 선언한 변수는 **참조(reference)** 를 변경할 수 없다는 의미이지
//  객체나 배열의 내부 상태는 변경할 수 있다는 점이 중요

//  리액트에서 const 사용 설명
//  1. 상수 값 선언
//  : 변경되지 않는 값을 선언할 때. 예를 들어 컴포넌트 내에서 변하지 않는 값을 선언할 때 적합
// const title = "Welcome to React";
// console.log(title); // Welcome to React

//  2. 함수 컴포넌트 정의 : 함수형 컴포넌트를 선언할 때 주로 사용
/*  예시
    const MyComponent = () => {
        return <h1>Hello, React!</h1>;
    };
    export default MyComponent;
 */

//  3. JSX 안에서 변수 사용 : JSX 안에서 렌더링 될 변수는 보통 const로 선언하는 경우가 많음
/*   예시
     const userName = "Alice";
     return <h1>Hello, {userName}!</h1>;
 */

//  4. 배열과 객체 선언
//  * const를 사용해 배열이나 객체를 선언할 때
//  배열의 요소나 객체의 속성은 변경이 가능하지만,
//  배열 또는 객체 자체를 다른 값으로 재할당 하는 것은 불가
/* 예시
    const numbers = [1, 2, 3];
    numbers.push(4); // 가능
    console.log(numbers); // [1, 2, 3, 4]

    // numbers = [5, 6, 7]; // 오류 발생! 재할당 불가

    const user = { name: "Alice", age: 25 };
    user.age = 26; // 가능
    console.log(user); // { name: "Alice", age: 26 }

    // user = { name: "Bob" }; // 오류 발생! 재할당 불가
*/

//  5. 리액트 훅과 함께 사용
//  리액트의 상태 관리에서 훅을 사용할 때도 const를 자주 사용
//  userState와 같은 훅은 구조 분해를 통해 상태값과 상태 업데이트 함수를 반환하므로
//  재할당을 막기 위해서 const를 사용


//  const 와 다른 선언 키워드(let, var)의 차이점
//  const
//  - 선언된 변수의 참조를 변경할 수 없음
//  - 반드시 선언 시 초기화해야 함

//  let
//  - 재할당이 가능하지만 재선언은 불가능
//  - 블록 스코프를 가짐

//  var
//  - 재할당 및 재선언이 가능
// - 함수 스코프를 가짐

//  리액트에서 const를 사용하는 이유
//  1. 불변성(immutability)을 유지
// : 리액트는 불변성을 중요하게 여기며, 상태나 데이터의 참조 변경을 방지하기 위해 const를 선호
//  2. 예측 가능한 코드
// : 한 번 선언된 값이 변경되지 않기 때문에 코드의 동작을 더 쉽게 예측할 수 있다.
//  3. 최신 문법 준수
// : ES6 이상에서 const 와 let은 표준으로 자리잡았음 (더 안전하고 직관적)
/*
리액트에서 const 는 불변 데이터를 다루거나 함수형 컴포넌트, 훅의 상태 선언 등에 널리 사용
데이터 참조를 안전하게 유지하고 코드의 가독성과 안정성을 높이는 데 중요한 역할을 합니다.
 */