
//  리액트의 기본 3요소
//  1. Virtual DOM
//  2. JSX
//  3. Component


//  * DOM(Document Object Model) == 문서 객체 모델
//  - 웹 문서(HTML, SVG, XML 등)을 브라우저가 이해할 수 있는 형태
//      1) 브라우저가 HTML 파일을 읽음
//      2) 각 HTML 요소는 노드(node) 라는 형태로 변환되어 DOM  트리를 형성
//  - 쉽게 말해 하나의 웹 사이트의 정보를 모두 담고 있는 큰 그릇
//  - 화면이 업데이트 된다 == DOM이 수정된다 (== 버튼 클릭, 입력 필드에 값 입력 등)
//  - 리액트는 화면 업데이트 시 실제 DOM을 직접 수정하지 않고
//    가상의 DOM(Virtual DOM)을 사용하여 변경 사항을 계산하여
//    실제 DOM에서 업데이트가 필요한 최소한의 부분만을 찾아서 수정
//    (빠른 화면 내용을 변경하기 위함)

    //  StateChange(상태변경) > Compute Diff(차이 계산) > Re-render(다시 그리기)
    //  StateChange : 상태에 변경사항이 발생하면
    //  ComputeDiff : Virtual DOM에서 업데이트가 필요한 최소한의 부분을 비교하여 검색하고
    //  Re-render : 검색된 부분만을 업데이트하고 다시 렌더링하면서 변경된 내용을 빠르게 사용자에게 보여줌



//  * JSX (Java Script XML)
//  : JSX 는 자바스크립트에 XML 같은 구문을 결합하여 UI를 정의하기 위해 고안된 문법.
//    JSX는 브라우저에서 실행되기 전에 React.createElement 호출하는 코드로 변환되며
//   반환값은 가상 DOM(Virtual DOM) 객체이다. 따라서 변수나 배열에 담을 수 있다.



//  * 컴포넌트 (Component)
//  - 리액트로 만들어진 앱을 이루는 최소한의 단위
//  - 컴포넌트는 데이터(props)를 입력받아 View(state) 상태에 따라 DOM Node를 출력하는 함수
//      >> "props"라고 하는 임의의 입력을 받은 후
//          화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반환
//  - 구성요소라는 뜻이며, 컴포넌트는 블록 형식이라 재사용성이 뛰어나다.
//  - UI를 재사용 가능한 개별적인 여러 조각으로 나누고, 각 조각을 개별적으로 나누어 코딩
//      == 하나의 컴포넌트는 여러 컴포넌트로 조합할 수 있다 (== 레고와 같다고 생각하면 쉬움)
//  - 컴포넌트 이름은 항상 대문자로 시작 (소문자로 시작하는 컴포넌트는 DOM 으로 취급)

//  컴포넌트의 종류
    //  1. 함수형 컴포넌트 (Functional Component)
    //  - Java Script 함수로 정의되는 React 컴포넌트
    //  - 초기에는 상태(State)를 관리하지 않아 Stateless Functional Component 라고 불렸음.
    //     >> React Hook 도입 이후 상태와 생명주기 관리 가능해짐
    //  - 함수처럼 정의되고 매개변수로 props 객체를 받고 JSX 로 반환 (== 렌더링)
    //  - 클래스형 컴포넌트보다 메모리 사용량이 적고 렌더링 속도가 빨라
    //     최신 버전에서는 함수형 컴포넌트와 훅을 권장하는 추세
    //  2. 클래스형 컴포넌트 (Class Component)
    //  - 리액트의 Component 클래스를 상속받으며 render() 메서드를 통해 UI를 렌더링
    //  - ES6의 클래스를 활용하며, 컴포넌트의 상태(State)가 내장되어 있음 (this.state 사용)


//  * Props 와 State
//  Props : 컴포넌트 외부에서 컴포넌트에게 주는 데이터.
//             부모 컴포넌트가 자식 컴포넌트에 데이터를 전달하기 위한 매커니즘.
//             props는 읽기 전용으로 자식 컴포넌트에서 직접 수정할 수 없음.
//             데이터 수정은 부모 컴포넌트에서 수정해야 함
//  State : 컴포넌트 내부에서 변경할 수 있는 동적인 데이터.
//            예전에는 클래스 컴포넌트에만 사용할 수 있었던 기능이나
//            현재는 Hooks을 사용하면 함수형 컴포넌트에도 사용 가능.
//            상태가 변경되면 해당 컴포넌트는 다시 렌더링 된다.



//  * 렌더링(Rendering)
//  : 리액트에서 렌더링은 컴포넌트가 UI를 화면에 표시하기 위해
//  JSX를 HTML로 변환하고 브라우저 DOM에 반영하는 과정을 의미
//  리액트는 상태(state)나 속성(props)의 변경에 따라 컴포넌트를 다시 렌더링하고,
//  이 과정에서 변경된 부분만 효율적으로 업데이트 함



//  * 훅(Hook)
//  : 함수형 컴포넌트에서 상태(state)와 컴포넌트 생명주기(lifecycle)를 사용할 수 있게 하는 기능
    //  훅의 특징
        //  1. 함수형 컴포넌트에서 상태와 생명주기 관리
        //  2. 코드 간결화
        //  3. 클래스 없이도 강력한 기능 제공
        //  4. 리액트 16.8 이상에서 도입된 기능으로
        //  클래스형 컴포넌트의 기능을 함수형 컴포넌트에서 사용할 수 있도록 지원
        //  (최신 리액트 개발에서는 훅을 사용하는 함수형 컴포넌트가 권장됨)

        //  대표적인 훅
        //  1. useState (상태 관리)         ***
        //  - 상태(state)를 관리하기 위한 훅
        //  - 상태와 상태를 업데이트하는 함수를 제공

        //  2. useEffect (사이드 이펙트 관리)         ***
        //  - 컴포넌트가 렌더링되거나 상태가 변경될 때 실행되는 코드를 정의
        //  - 주로 데이터 fetching, DOM 조작, 구독(subscription) 등에 사용됨

        //  3. useContext (컨텍스트 사용)         ***
        //  - 리액트의 Context API를 사용해 전역 상태를 쉽게 관리할 수 있도록 도와줌

        //  4. useReducer (복잡한 상태 관리)
        //  - 복잡한 상태를 관리할 때 useState 보다 더 강력한 기능을 제공
        //  - Redux와 유사한 방식으로 동작

        //  5. useRef (참조 관리)
        //  - DOM 요소나 컴포넌트의 **참조(reference)**를 저장할 때 사용
        //  - 값이 변경되어도 컴포넌트가 다시 렌더링되지 않음

    //  훅의 사용 규칙
    //  1. 최상위 레벨에서만 호출 (조건문이나 반복문 내부에서 호출 X)
    //  2. 리액트 함수형 컴포넌트 또는 커스텀 훅에서만 호출 (일반 자바스크립트 함수에서 호출 X)



//  export default function (컴포넌트명) 은
//  자바 스크립트의 모듈 시스템과 함수 선언을 결합한 구문으로
//  특정 컴포넌트를 기본 내보내기(default export)로 정의하는 것을 의미
//  리액트에서 주로 컴포넌트를 모듈화 하여 다른 파일에서 쉽게 가져다 쓸 수 있게 하는 데 사용됨
//  * 리액트에서 컴포넌트 모듈화란?
//  : 각 컴포넌트를 별도의 파일로 작성하고, 이를 모듈로 내보내는 것
//  * 참고 : 자바스크립트의 모듈 시스템
//  : 하나의 파일에서 정의된 코드를 다른 파일에서 가져와 사용할 수 있는 방식
//      - export : 다른 파일에서 사용 가능하도록 코드를 내보내기
//      - import : 다른 파일에서 내보낸 코드를 가져오기



//  리액트에서 Const 는 ES6에서 도입된 변수 선언 방식 중 하나로
//  변경 불가능한(immutable) 값을 선언할 때 사용됨
//  * const 로 선언한 변수는 **참조(reference)** 를 변경할 수 없다는 의미이지
//  객체나 배열의 내부 상태는 변경할 수 있다는 점이 중요

//  리액트에서 const 사용 설명
//  1. 상수 값 선언
//  : 변경되지 않는 값을 선언할 때. 예를 들어 컴포넌트 내에서 변하지 않는 값을 선언할 때 적합
// const title = "Welcome to React";
// console.log(title); // Welcome to React

//  2. 함수 컴포넌트 정의 : 함수형 컴포넌트를 선언할 때 주로 사용
/*  예시
    const MyComponent = () => {
        return <h1>Hello, React!</h1>;
    };
    export default MyComponent;
 */

//  3. JSX 안에서 변수 사용 : JSX 안에서 렌더링 될 변수는 보통 const로 선언하는 경우가 많음
/*   예시
     const userName = "Alice";
     return <h1>Hello, {userName}!</h1>;
 */

//  4. 배열과 객체 선언
//  * const를 사용해 배열이나 객체를 선언할 때
//  배열의 요소나 객체의 속성은 변경이 가능하지만,
//  배열 또는 객체 자체를 다른 값으로 재할당 하는 것은 불가
/* 예시
    const numbers = [1, 2, 3];
    numbers.push(4); // 가능
    console.log(numbers); // [1, 2, 3, 4]

    // numbers = [5, 6, 7]; // 오류 발생! 재할당 불가

    const user = { name: "Alice", age: 25 };
    user.age = 26; // 가능
    console.log(user); // { name: "Alice", age: 26 }

    // user = { name: "Bob" }; // 오류 발생! 재할당 불가
*/

//  5. 리액트 훅과 함께 사용
//  리액트의 상태 관리에서 훅을 사용할 때도 const를 자주 사용
//  userState와 같은 훅은 구조 분해를 통해 상태값과 상태 업데이트 함수를 반환하므로
//  재할당을 막기 위해서 const를 사용


//  const 와 다른 선언 키워드(let, var)의 차이점
//  const
//  - 선언된 변수의 참조를 변경할 수 없음
//     * 단, 참조 대상(객체나 배열)의 내부 상태는 변경 가능
//       ex) 객체의 속성을 변경하거나 배열에 요소를 추가하는 것   >> 가능
//             객체 자체를 다른 값으로 재할당                                   >> 불가능
//  - 반드시 선언 시 초기화해야 함

//  let
//  - 재할당이 가능하지만 재선언은 불가능
//  - 블록 스코프를 가짐

//  var
//  - 재할당 및 재선언이 가능
// - 함수 스코프를 가짐

//  리액트에서 const를 사용하는 이유
//  1. 불변성(immutability)을 유지
// : 리액트는 불변성을 유지하는 것을 중요하게 여기며,
//   이는 "상태가 직접 변경되지 않고 새로운 상태로 교체" 되어야 한다는 원칙.
//   >> 상태나 데이터의 참조 변경을 방지하기 위해 const를 선호
//  2. 예측 가능한 코드
// : 한 번 선언된 값이 변경되지 않기 때문에 코드의 동작을 더 쉽게 예측할 수 있다.
//  3. 최신 문법 준수
// : ES6 이상에서 const 와 let은 표준으로 자리잡았음 (더 안전하고 직관적)
/*
리액트에서 const 는 불변 데이터를 다루거나 함수형 컴포넌트, 훅의 상태 선언 등에 널리 사용
데이터 참조를 안전하게 유지하고 코드의 가독성과 안정성을 높이는 데 중요한 역할을 합니다.
 */



//  예제의